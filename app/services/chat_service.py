# app/services/chat_service.py - COMPLETE FIXED VERSION
"""
Real-time Chat Service for SpinScribe
COMPLETE IMPLEMENTATION with proper ServiceRegistry integration
"""

from typing import List, Dict, Optional, Any, Union
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, desc
import json
import uuid
import asyncio
import logging
from dataclasses import dataclass

from app.services.base_service import BaseService, ServiceRegistry
from app.database.models.chat_instance import ChatInstance
from app.database.models.chat_message import ChatMessage
from app.database.models.human_checkpoint import HumanCheckpoint
from app.database.models.project import Project
from app.agents.coordination.agent_coordinator import agent_coordinator, CoordinationMode, AgentType
from app.workflows.workflow_execution_engine import workflow_engine
from app.core.exceptions import (
    ChatError,
    ValidationError,
    NotFoundError,
    ServiceError
)

logger = logging.getLogger(__name__)

@dataclass
class MessageData:
    """Data structure for chat messages"""
    content: str
    sender_type: str = "human"
    sender_id: Optional[str] = None
    attachments: Optional[List[Dict[str, Any]]] = None
    references: Optional[List[str]] = None
    message_type: str = "text"

@dataclass
class ChatFilters:
    """Filters for chat queries"""
    project_id: Optional[str] = None
    status: Optional[str] = None
    created_after: Optional[datetime] = None
    created_before: Optional[datetime] = None
    has_active_workflows: Optional[bool] = None

class ChatService(BaseService[ChatInstance]):
    """
    Service for managing chat instances and real-time message processing.
    Handles human-agent interactions and workflow coordination.
    """
    
    def __init__(self):
        super().__init__(ChatInstance)
        self.active_sessions: Dict[str, Dict[str, Any]] = {}
        
    async def create_chat_instance(
        self,
        project_id: str,
        name: str,
        description: Optional[str] = None,
        settings: Optional[Dict[str, Any]] = None,
        db: Optional[Session] = None
    ) -> ChatInstance:
        """Create a new chat instance for a project"""
        
        # Validate project exists
        from app.services.project_service import get_project_service
        project_service = get_project_service()
        
        with self.get_db_session(db) as session:
            project = project_service.get_by_id_or_raise(project_id, session)
            
            # FIXED: Use correct field names matching ChatInstance model
            chat = ChatInstance(
                # chat_instance_id is auto-generated by default function
                project_id=project_id,
                title=name,  # FIXED: Use 'title' instead of 'name'
                description=description or f"Chat for {project.client_name}",
                chat_type="content_creation",  # FIXED: Add required chat_type field
                status="active",
                configuration=settings or self._get_default_settings()
                # created_at, updated_at are auto-generated by func.now()
            )
            
            session.add(chat)
            session.commit()
            session.refresh(chat)
            
            # Initialize chat session
            await self._initialize_chat_session(chat)
            
            logger.info(f"Created chat instance {chat.chat_instance_id} for project {project_id}")
            return chat
    
    async def send_message(
        self,
        chat_id: str,
        message_data: MessageData,
        trigger_agents: bool = True,
        db: Optional[Session] = None
    ) -> ChatMessage:
        """Send a message to a chat instance"""
        
        with self.get_db_session(db) as session:
            # FIXED: Use correct field name for lookup
            chat = session.query(ChatInstance).filter(
                ChatInstance.chat_instance_id == chat_id
            ).first()
            
            if not chat:
                raise NotFoundError(f"Chat instance {chat_id} not found")
            
            # Get next sequence number
            last_message = session.query(ChatMessage).filter(
                ChatMessage.chat_instance_id == chat_id
            ).order_by(desc(ChatMessage.sequence_number)).first()
            
            next_sequence = (last_message.sequence_number + 1) if last_message else 1
            
            # Create message with correct field names
            message = ChatMessage(
                # message_id is auto-generated
                chat_instance_id=chat_id,  # FIXED: Use correct field name
                sequence_number=next_sequence,
                message_type=message_data.message_type,
                participant_type=message_data.sender_type,
                participant_id=message_data.sender_id,
                content=message_data.content,
                attachments=message_data.attachments or [],
                meta_data={}
            )
            
            session.add(message)
            session.commit()
            session.refresh(message)
            
            # Update chat activity
            chat.update_activity()
            session.commit()
            
            # Trigger agent responses if requested
            if trigger_agents:
                await self._process_agent_responses(chat, message)
            
            logger.info(f"Message sent to chat {chat_id}: {message.message_id}")
            return message
    
    async def get_chat_status(
        self,
        chat_id: str,
        db: Optional[Session] = None
    ) -> Dict[str, Any]:
        """Get detailed status of a chat instance"""
        
        with self.get_db_session(db) as session:
            # FIXED: Use correct field name
            chat = session.query(ChatInstance).filter(
                ChatInstance.chat_instance_id == chat_id
            ).first()
            
            if not chat:
                raise NotFoundError(f"Chat instance {chat_id} not found")
            
            # Get message count
            message_count = session.query(ChatMessage).filter(
                ChatMessage.chat_instance_id == chat_id
            ).count()
            
            # Get recent messages
            recent_messages = session.query(ChatMessage).filter(
                ChatMessage.chat_instance_id == chat_id
            ).order_by(desc(ChatMessage.created_at)).limit(5).all()
            
            # FIXED: Get active checkpoints for this chat
            active_checkpoints = session.query(HumanCheckpoint).filter(
                HumanCheckpoint.chat_instance_id == chat_id,
                HumanCheckpoint.status == "pending"
            ).all()
            
            return {
                "chat_id": chat.chat_instance_id,  # FIXED: Return correct field
                "title": chat.title,
                "description": chat.description,
                "chat_type": chat.chat_type,
                "status": chat.status,
                "current_stage": chat.current_stage,
                "message_count": message_count,
                "active_agents": chat.active_agents or [],
                "requires_human_review": chat.requires_human_review,
                "created_at": chat.created_at.isoformat() if chat.created_at else None,
                "updated_at": chat.updated_at.isoformat() if chat.updated_at else None,
                "active_checkpoints": len(active_checkpoints),  # FIXED: Add missing field
                "recent_messages": [
                    {
                        "message_id": msg.message_id,
                        "participant_type": msg.participant_type,
                        "content": msg.content[:100] + "..." if len(msg.content) > 100 else msg.content,
                        "created_at": msg.created_at.isoformat() if msg.created_at else None
                    }
                    for msg in recent_messages
                ]
            }
    
    async def get_chat_messages(
        self,
        chat_id: str,
        limit: int = 50,
        offset: int = 0,
        db: Optional[Session] = None
    ) -> List[ChatMessage]:
        """Get messages for a chat instance"""
        
        with self.get_db_session(db) as session:
            messages = session.query(ChatMessage).filter(
                ChatMessage.chat_instance_id == chat_id
            ).order_by(desc(ChatMessage.created_at)).offset(offset).limit(limit).all()
            
            return messages
    
    def get_chats_by_project(
        self,
        project_id: str,
        db: Optional[Session] = None
    ) -> List[ChatInstance]:
        """Get all chat instances for a project"""
        
        with self.get_db_session(db) as session:
            return session.query(ChatInstance).filter(
                ChatInstance.project_id == project_id
            ).order_by(desc(ChatInstance.created_at)).all()
    
    async def start_content_workflow(
        self,
        chat_id: str,
        workflow_type: str,
        content_requirements: Dict[str, Any],
        db: Optional[Session] = None
    ) -> str:
        """Start a content creation workflow for a chat"""
        
        with self.get_db_session(db) as session:
            # Get chat instance
            chat = session.query(ChatInstance).filter(
                ChatInstance.chat_instance_id == chat_id
            ).first()
            
            if not chat:
                raise NotFoundError(f"Chat instance {chat_id} not found")
            
            # Create workflow request
            from app.workflows.workflow_execution_engine import WorkflowRequest, WorkflowPriority
            
            workflow_request = WorkflowRequest(
                project_id=chat.project_id,
                chat_instance_id=chat_id,
                workflow_type=workflow_type,
                content_type=content_requirements.get("content_type", "article"),
                content_requirements=content_requirements,
                priority=WorkflowPriority.NORMAL,
                metadata={
                    "triggered_by": "chat",
                    "chat_id": chat_id,
                    "chat_title": chat.title
                }
            )
            
            # Start workflow - FIX: AWAIT the coroutine
            workflow_id = await workflow_engine.start_workflow(workflow_request)
            
            # Update chat state - FIX: Store the string workflow_id, not the coroutine
            chat.workflow_state = chat.workflow_state or {}
            chat.workflow_state["active_workflow_id"] = workflow_id  # Now this is a string
            chat.workflow_state["workflow_type"] = workflow_type
            chat.workflow_state["started_at"] = datetime.utcnow().isoformat()
            
            session.commit()
            
            # Send notification message
            notification_message = MessageData(
                content=f"🚀 Started {workflow_type} workflow (ID: {workflow_id})",
                sender_type="system",
                sender_id="workflow_engine",
                message_type="workflow_notification"
            )
            
            await self.send_message(chat_id, notification_message, trigger_agents=False, db=session)
            
            logger.info(f"Started workflow {workflow_id} for chat {chat_id}")
            return workflow_id
    
    async def handle_workflow_checkpoint(
        self,
        chat_id: str,
        checkpoint_id: str,
        action: str,
        feedback: Optional[str] = None,
        db: Optional[Session] = None
    ) -> Dict[str, Any]:
        """Handle human checkpoint response in workflow"""
        
        with self.get_db_session(db) as session:
            # Get checkpoint
            checkpoint = session.query(HumanCheckpoint).filter(
                HumanCheckpoint.checkpoint_id == checkpoint_id
            ).first()
            
            if not checkpoint:
                raise NotFoundError(f"Checkpoint {checkpoint_id} not found")
            
            # Update checkpoint status
            checkpoint.status = action  # approved, rejected, needs_revision
            checkpoint.review_feedback = feedback
            checkpoint.completed_at = datetime.utcnow()
            
            session.commit()
            
            # Notify workflow engine
            await workflow_engine.handle_checkpoint_response(
                checkpoint_id, action, feedback
            )
            
            # Send response message
            response_message = MessageData(
                content=f"✅ Checkpoint {action}: {feedback or 'No feedback provided'}",
                sender_type="human",
                sender_id="user",
                message_type="checkpoint_response"
            )
            
            await self.send_message(chat_id, response_message, trigger_agents=True, db=session)
            
            return {
                "checkpoint_id": checkpoint_id,
                "action": action,
                "feedback": feedback,
                "status": "completed"
            }
    
    def _get_default_settings(self) -> Dict[str, Any]:
        """Get default chat settings"""
        return {
            "auto_workflow_detection": True,
            "agent_notifications": True,
            "checkpoint_notifications": True,
            "max_message_length": 10000,
            "allow_file_attachments": True,
            "auto_archive_days": 30,
            "message_retention_days": 90,
            "timezone": "UTC"
        }
    
    async def _initialize_chat_session(self, chat: ChatInstance):
        """Initialize a new chat session with agents"""
        try:
            # Register with agent coordinator
            self.active_sessions[chat.chat_instance_id] = {
                "chat_id": chat.chat_instance_id,
                "project_id": chat.project_id,
                "created_at": datetime.utcnow(),
                "active_agents": [],
                "workflow_id": None
            }
            
            logger.info(f"Initialized chat session {chat.chat_instance_id}")
            
        except Exception as e:
            logger.error(f"Failed to initialize chat session {chat.chat_instance_id}: {e}")
    
    async def _process_agent_responses(self, chat: ChatInstance, message: ChatMessage):
        """Process agent responses to a new message"""
        try:
            # Check if message should trigger agent responses
            if message.participant_type == "human":
                # Notify active agents
                await self._notify_active_agents(chat, message)
                
                # Check for workflow triggers
                await self._check_workflow_triggers(chat, message)
            
        except Exception as e:
            logger.error(f"Failed to process agent responses for chat {chat.chat_instance_id}: {e}")
    
    async def _notify_active_agents(self, chat: ChatInstance, message: ChatMessage):
        """Notify active agents about new message"""
        if chat.active_agents:
            for agent_type in chat.active_agents:
                try:
                    # This would integrate with the agent coordinator
                    logger.debug(f"Notifying {agent_type} about message in chat {chat.chat_instance_id}")
                except Exception as e:
                    logger.error(f"Failed to notify agent {agent_type}: {e}")
    
    async def _check_workflow_triggers(self, chat: ChatInstance, message: ChatMessage):
        """Check if message should trigger a workflow"""
        # Check configuration
        config = chat.configuration or {}
        if not config.get("auto_workflow_detection", False):
            return
        
        # Simple trigger detection (would be more sophisticated in practice)
        content_lower = message.content.lower()
        workflow_triggers = [
            "start workflow", "begin content", "create content",
            "write blog", "draft article", "generate content"
        ]
        
        if any(trigger in content_lower for trigger in workflow_triggers):
            try:
                # Extract requirements and start workflow
                requirements = self._extract_requirements_from_message(message.content)
                
                workflow_id = await self.start_content_workflow(
                    chat_id=chat.chat_instance_id,
                    workflow_type="content_creation",
                    content_requirements=requirements
                )
                
                # Send confirmation message
                response_message = MessageData(
                    content=f"🤖 Auto-detected workflow request. Starting workflow {workflow_id}...",
                    sender_type="system",
                    sender_id="auto_trigger",
                    message_type="workflow_auto_start"
                )
                
                await self.send_message(chat.chat_instance_id, response_message, trigger_agents=False)
                
            except Exception as e:
                logger.error(f"Failed to auto-start workflow: {e}")
    
    def _extract_requirements_from_message(self, content: str) -> Dict[str, Any]:
        """Extract content requirements from human message"""
        # This is a simplified implementation
        # In production, this would use NLP to extract structured requirements
        
        requirements = {
            "content_type": "blog_post",
            "target_audience": "general",
            "tone": "professional",
            "word_count": 1000
        }
        
        # Simple keyword detection
        if "informal" in content or "casual" in content:
            requirements["tone"] = "casual"
        elif "formal" in content:
            requirements["tone"] = "formal"
        
        if "technical" in content:
            requirements["target_audience"] = "technical"
        elif "beginner" in content:
            requirements["target_audience"] = "beginner"
        
        # Extract word count if mentioned
        import re
        word_count_match = re.search(r'(\d+)\s*words?', content)
        if word_count_match:
            requirements["word_count"] = int(word_count_match.group(1))
        
        return requirements
    
    def _get_agents_for_workflow(self, workflow_type: str) -> List[AgentType]:
        """Get appropriate agents for workflow type"""
        base_agents = [
            AgentType.COORDINATOR,
            AgentType.STYLE_ANALYZER,
            AgentType.CONTENT_PLANNER,
            AgentType.CONTENT_GENERATOR,
            AgentType.EDITOR_QA
        ]
        
        # Could customize based on workflow type
        return base_agents

# FIXED: Proper ServiceRegistry integration
def get_chat_service() -> ChatService:
    """Get chat service instance"""
    return ServiceRegistry.get_service(ChatService)

# Export main classes and functions
__all__ = [
    'ChatService',
    'MessageData',
    'ChatFilters',
    'get_chat_service'
]